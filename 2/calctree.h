/*
В текстовом файле с именем filename дано арифметическое выражение в префиксной
форме. Операндами в выражении являются целые числа из промежутка от 0 до 9. Используемые
операции: сложение(+), вычитание(-), умножение(*), деление нацело(/), целочисленный остаток
от деления(%) и возведение в степень(^). Постройте дерево, соответствующее данному выражению. Знаки операций кодируйте числами: сложение(-1), вычитание(-2), умножение(-3), деление(-
4), остаток от деления(-5), возведение в степень (-6). Преобразуйте дерево, вычислив значения
всех поддеревьев, для которых результат вычислений является числом из промежутка от 0 до 9
(замените такие поддеревья их значениями). Выведите указатель на корень полученного дерева
*/

#include <memory>
#include <string>
#include <sstream>

/**
 * @enum Operation
 * @brief Коды арифметических операций
 *
 * Используются для представления операций в узлах дерева:
 * - Отрицательные значения: операции
 * - Положительные (0-9): операнды
 */
enum Operation {
    ADD = -1, SUB = -2, MUL = -3, DIV = -4, MOD = -5, POW = -6
};

/**
 * @struct Node
 * @brief Узел бинарного дерева выражения
 *
 * Хранит значение узла (операнд или код операции) и
 * умные указатели на дочерние узлы.
 */
struct Node {
    int value;                      ///< Значение узла
    std::unique_ptr<Node> left;     ///< Левый потомок
    std::unique_ptr<Node> right;    ///< Правый потомок

    /**
     * @brief Конструктор узла
     * @param val Значение узла (операнд или код операции)
     */
    explicit Node(int val) : value(val), left(nullptr), right(nullptr) {}
};

/**
 * @class CalcTree
 * @brief Основной класс для работы с деревьями выражений
 *
 * Реализует построение дерева из префиксного выражения,
 * оптимизацию поддеревьев и предоставляет доступ к корню.
 */
class CalcTree {
public:
    /**
     * @brief Конструктор из файла
     * @param filename Имя файла с префиксным выражением
     */
    explicit CalcTree(const std::string& filename);

    /**
     * @brief Проверить наличие ошибок
     * @return true если при построении дерева были ошибки
     */
    bool HasErrors() const { return errorFlag; }

    /**
     * @brief Получить корень дерева
     * @return Указатель на корневой узел
     */
    Node* GetRoot() const { return root.get(); }

    /**
     * @brief Оптимизировать дерево
     *
     * Заменяет поддеревья с результатами 0-9 на листовые узлы.
     * Выполняет оптимизацию до стабилизации дерева.
     */
    void Simplify();

private:
    std::unique_ptr<Node> root;  ///< Корень дерева
    std::istringstream ss;       ///< Поток для чтения выражения
    bool errorFlag = false;      ///< Флаг наличия ошибок

    /**
     * @brief Рекурсивное построение дерева
     * @return Умный указатель на построенный узел
     */
    std::unique_ptr<Node> BuildTree();

    /**
     * @brief Рекурсивная оптимизация узла
     * @param node Текущий оптимизируемый узел
     * @return true если дерево было изменено
     */
    bool Evaluate(std::unique_ptr<Node>& node);

    /**
     * @brief Вычислить операцию над операндами
     * @param a Левый операнд
     * @param b Правый операнд
     * @param op Код операции
     * @return Результат вычисления
     */
    bool Compute(int a, int b, Operation op, int& result) const;
};
